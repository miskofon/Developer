<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - geometry - cube</title>
		<meta charset="utf-8">
		<style>
			body {
				margin: 0px;
				background-color: #000000;
				overflow: hidden;
			}
			
			.action-button {
				border-radius: 10px;
				background-color: #ffffff;
				margin: 5px;
				padding: 10px;
				text-align: center;
				box-shadow: 7px 7px 5px #888888;
				z-index: 100;
				position: absolute;
			}
			
			.action-button:hover, .action-button-running {
				margin-left: 7px;
				margin-top: 7px;
				box-shadow: 4px 4px 5px #888888;
			}
			
			.action-button-running {
				font-weight: bold;
			}
			
		</style>
		<script src="js/three.js"></script>
		<script src="js/Detector.js"></script>
		<script src="js/jquery-2.1.3.min.js"></script>
	</head>
	<body>
		<div id="addWall" class="action-button" style="top: 0px; width: 80px;"><div onClick="window.engine.startAddWall();">Add wall</div></div>
		<div id="outputDiv"></div>
		<script>

			window.engine = new DevEngine() || {};
			
			function DevObject() {
				this.id = null;
				this.objectType = null;
			};
			
			function DevDatabase() {
				this.objects = [];
			};
			
			DevDatabase.prototype.addObject = function(object) {
				if (object instanceof DevObject) {				
					$.each(this.objects, function(index, obj) {
						if (object.id == obj.id) {
							return false;
						}
					});
					this.objects.push(object);
					return true;
				} else {
					return false;
				}
			};
			
			DevDatabase.prototype.getObjectBy = function(propName, propValue) {
				var foundObjects = [];
				$.each(this.objects, function(index, object) {
					if (object[propName] != undefined && object[propName] == propValue) {
						foundObjects.push(object);
					}
				});
				
				return foundObjects;
			};
			
			function DisplayedObject() {
				this.visible = false;
				this.mesh = null;
			};
			
			DisplayedObject.prototype.getMesh = function() {
				return this.mesh;
			};
			
			DisplayedObject.prototype.isVisible = function() {
				if (this.mesh == null) {
					return false;
				}
				return this.visible;
			};
			
			function DevEngine() {
				this.walls = [];
				this.interactions = [];
				this.activeIntercation = null;
				this.meshes = [];
				this.floors = [];
				this.lights = [];
				this.temporaryObjects = [];
				this.objects = [];
				this.renderer = {};
				this.mapObjects = new Map();
			};

			SimpleFloor.prototype = new DisplayedObject();
			SimpleFloor.prototype.constructor = SimpleFloor;
			function SimpleFloor(position, depth, width, color) {
				this.pos = position;
				this.width = width;
				this.depth = depth;
				this.color = color;
			};
			
			SimpleFloor.prototype.createMesh = function() {
				var material = new THREE.MeshBasicMaterial({color: this.color});
				this.mesh = new THREE.Mesh(new THREE.PlaneGeometry(this.width, this.depth), material);
				this.mesh.position.x = this.pos.x;
				this.mesh.position.y = this.pos.y;
				this.mesh.position.z = this.pos.z;
				this.visible = true;
			};
			
			
			SimpleWall.prototype = new DisplayedObject();
			function SimpleWall() {
				this.createMesh = function(pos) {
					this.mesh = this.generateMesh(pos, pos, 2, 20);
					this.visible = true;
				};
				
				this.recreateMesh = function(startPos, endPos) {
					var oldMesh = this.getMesh();
					if (oldMesh == undefined | oldMesh == null) {
						return;
					}
					
					this.mesh = this.generateMesh(startPos, endPos, 2, 20);
				};
				
				this.generateMesh = function(start, end, width, height) {
					var wallMesh = new THREE.Object3D();
					
					var length = end.distanceTo(start);
					if (length < width) {
						length = width;
					}
					
					var div = new THREE.Vector2().subVectors(end,start);
					var wallColor = 0x808080;
					//create front plane
					var inter = new THREE.Mesh(new THREE.PlaneGeometry(length, height), new THREE.MeshBasicMaterial({color: wallColor}));
					//var frontTransform = new THREE.Matrix4();
					//frontTransform.makeRotationX(Math.PI);
					//front.matrix = frontTransform;
					inter.lookAt(new THREE.Vector3(1.0, 0.0, 0.0));
					inter.rotation.x = Math.PI / 2;
					inter.position.x = width / 2;
					inter.position.y = -length /2;
					inter.position.z = height / 2;
					wallMesh.add(inter);
					
					var outSide = new THREE.Mesh(new THREE.PlaneGeometry(length, height), new THREE.MeshBasicMaterial({color: wallColor}));
					outSide.lookAt(new THREE.Vector3(-1.0, 0.0, 0.0));
					outSide.rotation.x = Math.PI / 2;
					outSide.position.x = -width / 2;
					outSide.position.y =- length / 2;
					outSide.position.z = height / 2;
					wallMesh.add(outSide);
					
					var back = new THREE.Mesh(new THREE.PlaneGeometry(width, height), new THREE.MeshBasicMaterial({color: wallColor}));
					back.lookAt(new THREE.Vector3(0.0, 1.0, 0.0));
					back.rotation.z = 0;
					back.position.y = 0;
					back.position.z = height / 2;
					back.doubleSide = true;
					wallMesh.add(back);
					
					var front = new THREE.Mesh(new THREE.PlaneGeometry(width, height), new THREE.MeshBasicMaterial({color: wallColor}));
					front.lookAt(new THREE.Vector3(0.0, -1.0, 0.0));
					front.rotation.z = 0;
					front.position.x = 0;
					front.position.y = -length;
					front.position.z = height / 2;
					wallMesh.add(front);
					
					var top = new THREE.Mesh(new THREE.PlaneGeometry(width, length), new THREE.MeshBasicMaterial({color: 0xffffff}));
					top.lookAt(new THREE.Vector3(0.0, 0.0, 1.0));
					top.position.x = 0;
					top.position.y = -length/2;
					top.position.z = height;
					wallMesh.add(top);
					
					
					if (div.x != 0 || div.y != 0) {
						wallMesh.rotation.z = new THREE.Vector3(div.x, div.y, 0).angleTo(new THREE.Vector3(0.0, -1.0, 0.0)) * Math.sign(div.x);
					}
					wallMesh.position.copy(start);
					return wallMesh;
				};
				
				this.setPosition = function(pos) {
					this.mesh.position.copy(pos);
				};
			};
			
			SelectionPointer.prototype = new DisplayedObject();
			function SelectionPointer() {
				this.createMesh = function() {
					var geometry = new THREE.SphereGeometry( 1, 32, 32 ); 
					var material = new THREE.MeshBasicMaterial( {color: 0xffff00} ); 
					this.mesh = new THREE.Mesh( geometry, material );
				};
			};
			
			function SimpleInteraction(engine,floor) {
				this.engine = engine;
				this.floor = floor;
				this.wall = null;
				this.startPoint = null;
				this.selectionObject = null;
				this.start = function() {
					this.selectionObject = new SelectionPointer();
					this.selectionObject.createMesh();
				};
				this.onMouseMove = function(event, intersections) {
					var intersection = null;
					for(i=0; i<intersections.length; ++i) {
						if (intersections[i].object.id == this.floor.mesh.id) {
							intersection = intersections[i];
							break;
						}
					}
						
					if (this.wall != undefined && this.wall != null) {
						if (intersection != null) {
							this.wall.recreateMesh(this.startPoint, new THREE.Vector2(intersection.point.x, intersection.point.y));
							var mesh = this.wall.getMesh();
							mesh.position.z = 0;
							if (this.selectionObject != null) {
								this.selectionObject.getMesh().position.copy(intersection.point);
							}
						}
					}
					
					if (intersection != null) {
						if (this.selectionObject != null) {
							this.selectionObject.getMesh().position.copy(intersection.point);
							this.selectionObject.visible = true;
						} else {
							this.selectionObject.visible = false;
						}
					}
				};
				
				this.onKeyPressed = function(event) {

				};

				this.onClick = function(event, intersections) {
					if (this.wall == undefined || this.wall == null) {
						if (intersections.length > 0) {
							this.wall = new SimpleWall();
							var point = intersections[0].point;
							var pos = new THREE.Vector2(point.x, point.y);
							this.wall.createMesh(pos);
							this.startPoint = pos;
						}
					} else {
						this.engine.objects.push(this.wall);
						this.wall = null;
						this.startPoint = null;
					}
				};
				
				this.getObjects2Display = function() {
					var objects = [];
					if (this.wall != undefined && this.wall != null) {
						objects.push(this.wall);
					}
					if (this.selectionObject != null) {
						objects.push(this.selectionObject);
					};
					return objects;
				};
			};
					
			DevEngine.prototype.init = function() {
				this.WIDTH = window.innerWidth;
				this.HEIGHT = window.innerHeight;
				
				var container = $("#outputDiv")[0];
				
				this.scene = new THREE.Scene();
				this.renderer = new THREE.WebGLRenderer({antialias:true}); 
				
				this.renderer.setSize( this.WIDTH, this.HEIGHT );
				this.renderer.setClearColor(0xf0f0f0);
				
				this.addLight( new THREE.AmbientLight( 0x505050 ) );
				
				var light = new THREE.SpotLight( 0xffffff, 1.5 );
				light.position.set( 0, 500, 2000 );
				light.castShadow = true;
				
				this.addLight(light);
				
				this.camera = new THREE.PerspectiveCamera( 50, this.WIDTH / this.HEIGHT, 1, 1000 );
				this.camera.position.x = 0;
				this.camera.position.y = -300;
				this.camera.position.z = 50;
				this.camera.lookAt(this.scene.position);
			
				container.appendChild( this.renderer.domElement );
				
				var that = this;
				window.addEventListener( 'resize', function() { that.onWindowResize();} , false );
				window.addEventListener( 'mousemove', function(event) { that.onMouseMove(event);} , false );
				window.addEventListener( 'mousedown', function() { that.onMouseDown();} , false );
				window.addEventListener( 'mouseup', function() { that.onMouseUp();} , false );
				window.addEventListener( 'click', function(event) { that.onClick(event);} , false );
				$(document).keypress(function(event) { that.onKeyPressed(event); });
				$(document).keyup(function(event) { that.onKeyUp(event); });
			};
			
			DevEngine.prototype.onKeyPressed = function(event) {
				if (this.activeInteraction != undefined) {
					if (typeof this.activeInteraction.onKeyPressed == 'function') {
						this.activeInteraction.onKeyPressed(event);
					}
				}
			};
			
			DevEngine.prototype.onKeyUp = function(event) {
				if (this.activeInteraction != undefined) {
					if (event.keyCode == 27) {
						this.activeInteraction = undefined;
						$("#addWall").removeClass("action-button-running");
						return;
					}
				}
			};
			
			DevEngine.prototype.onMouseMove = function(event) {
				if (this.activeInteraction != undefined) {
					if (typeof this.activeInteraction.onMouseMove == 'function') {
												event.preventDefault();
						var mouse = new THREE.Vector2()
						mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
						mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;					
						var vector = new THREE.Vector3( mouse.x, mouse.y, 0.5 ).unproject( this.camera );

						var raycaster = new THREE.Raycaster( this.camera.position, vector.sub( this.camera.position ).normalize() );
						var intersections = raycaster.intersectObject(this.scene, true);
			
						this.activeInteraction.onMouseMove(event, intersections);
					}
				}
			};
			
			DevEngine.prototype.onMouseUp = function(event) {
				if (this.activeInteraction != undefined) {
					if (typeof this.activeInteraction.onMouseUp == 'function') {
						this.activeInteraction.onMouseUp(event);
					}
				}
			};
			
			DevEngine.prototype.onMouseDown = function(event) {
				if (this.activeInteraction != undefined) {
					if (typeof this.activeInteraction.onMouseDown == 'function') {
						this.activeInteraction.onMouseDown(event);
					}
				}
			};
			
			DevEngine.prototype.onClick = function(event) {
				if (this.activeInteraction != undefined) {
					if (typeof this.activeInteraction.onClick == 'function') {
						event.preventDefault();
						var mouse = new THREE.Vector2()
						mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
						mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;					
						var vector = new THREE.Vector3( mouse.x, mouse.y, 0.5 ).unproject( this.camera );

						var raycaster = new THREE.Raycaster( this.camera.position, vector.sub( this.camera.position ).normalize() );
						var intersections = raycaster.intersectObject(this.scene, true);
			
						this.activeInteraction.onClick(event, intersections);
					}
				}
			};
			
			DevEngine.prototype.addMeshElement = function(mesh) {
				if ($.inArray(mesh, this.scene.children) == -1) {
						this.scene.add(mesh);
					}
			};
			
			DevEngine.prototype.addFloor = function (floor) {
				this.floors.push(floor);
				this.addObject(floor);
				//this.addMeshElement(floor.getMesh());
			};
			
			DevEngine.prototype.addObject = function(object) {
				if (object instanceof DisplayedObject) {
					if ($.inArray(object, this.objects) == -1) {
						this.objects.push(object);
					}
				} else {
					console.log("Object of incorrect type added. Type:" + typeof object);
				}
			};
			
			DevEngine.prototype.addLight = function(light) {
				this.lights.push(light);
			};
			
			DevEngine.prototype.start = function() {
				var that = this;
				requestAnimationFrame(function() { that.animate();} );
				
				var floor = new SimpleFloor(new THREE.Vector3( 0, 0, 0 ), 400, 400, 0x5050FF);
				floor.createMesh();
				this.addFloor(floor);
				
				//this.activeInteraction = new SimpleInteraction(this, floor);
				//this.interactions.push(this.activeInteraction);
			};
			
			DevEngine.prototype.startAddWall = function() {
				this.activeInteraction = new SimpleInteraction(this, this.floors[0]);
				this.interactions.push(this.activeInteraction);
				this.activeInteraction.start();
				
				$("#addWall").addClass("action-button-running");
			};

			DevEngine.prototype.animate = function() {
				var that = this;
				
				//handle interactions
				that.temporaryObjects = [];
				if (this.activeInteraction != undefined) {
					var objects = this.activeInteraction.getObjects2Display();
					$.each(objects, function(objectIndex, object) {
						that.temporaryObjects.push(object);
					});
				}
				
				//clear scene
				$.each(this.scene.children, function(index, object) {
					that.scene.remove(object);
				});
				
				this.mapObjects.clear();
				
				//add lights
				$.each(this.lights, function(index, light) {
					that.scene.add(light);
				});
				
				//add objects
				$.each(this.objects, function(index, object) {
					if (object.isVisible()) {
						var mesh = object.getMesh();
						that.scene.add(mesh);
						that.mapObjects.set(mesh, object);
					}
				});

				//add temporary objects
				$.each(this.temporaryObjects, function(index, object) {
					if (object.isVisible()) {
						var mesh = object.getMesh();
						that.scene.add(mesh);
						that.mapObjects.set(mesh, object);
					}
				});
				
				this.renderer.render( this.scene, this.camera );
				requestAnimationFrame(function() { that.animate();} );
			};
			
			DevEngine.prototype.onWindowResize = function () {
				
				this.camera.aspect = window.innerWidth / window.innerHeight;
				this.camera.updateProjectionMatrix();

				this.renderer.setSize( window.innerWidth, window.innerHeight );
			}
			
			
			window.engine.init();
			window.engine.start();

		</script>

	</body>
</html>
