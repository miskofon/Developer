<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - geometry - cube</title>
		<meta charset="utf-8">
		<style>
			body {
				margin: 0px;
				background-color: #000000;
				overflow: hidden;
			}
			
			.action-button {
				border-radius: 10px;
				background-color: #ffffff;
				margin: 5px;
				padding: 10px;
				text-align: center;
				box-shadow: 7px 7px 5px #888888;
				z-index: 100;
				position: absolute;
			}
			
			.action-button:hover, .action-button-running {
				margin-left: 7px;
				margin-top: 7px;
				box-shadow: 4px 4px 5px #888888;
			}
			
			.action-button-running {
				font-weight: bold;
			}
			
		</style>
		<script src="js/three.js"></script>
		<script src="js/Detector.js"></script>
		<script src="js/jquery-2.1.3.min.js"></script>
		<script src="js/lodash.min.js"></script>
		<script src="js/ObjectsStorer.js"></script>
		<script src="js/DevEngine.js"></script>
	</head>
	<body>
		<div id="addWall" class="action-button" style="top: 0px; width: 80px;"><div onClick="window.engine.startAddWall();">Add wall</div></div>
		<div id="outputDiv"></div>
		<script>

			window.engine = new DevEngine() || {};
			window.objectsStorer = new DevDatabase() || {};
			
			SimpleFloor.prototype = new DisplayedObject();
			SimpleFloor.prototype.constructor = SimpleFloor;
			function SimpleFloor(position, depth, width, color) {
				this.pos = position;
				this.width = width;
				this.depth = depth;
				this.color = color;
			};
			
			SimpleFloor.prototype.createMesh = function() {
				var material = new THREE.MeshBasicMaterial({color: this.color});
				this.mesh = new THREE.Mesh(new THREE.PlaneGeometry(this.width, this.depth), material);
				this.mesh.position.x = this.pos.x;
				this.mesh.position.y = this.pos.y;
				this.mesh.position.z = this.pos.z;
				this.visible = true;
			};
			
			
			SimpleWall.prototype = new DisplayedObject();
			function SimpleWall() {
				this.createMesh = function(pos) {
					this.mesh = this.generateMesh(pos, pos, 2, 20);
					this.visible = true;
				};
				
				this.recreateMesh = function(startPos, endPos) {
					var oldMesh = this.getMesh();
					if (oldMesh == undefined | oldMesh == null) {
						return;
					}
					
					this.mesh = this.generateMesh(startPos, endPos, 2, 20);
				};
				
				this.generateMesh = function(start, end, width, height) {
					var wallMesh = new THREE.Object3D();
					
					var length = end.distanceTo(start);
					if (length < width) {
						length = width;
					}
					
					var div = new THREE.Vector2().subVectors(end,start);
					var wallColor = 0x808080;
					//create front plane
					var inter = new THREE.Mesh(new THREE.PlaneGeometry(length, height), new THREE.MeshBasicMaterial({color: wallColor}));
					//var frontTransform = new THREE.Matrix4();
					//frontTransform.makeRotationX(Math.PI);
					//front.matrix = frontTransform;
					inter.lookAt(new THREE.Vector3(1.0, 0.0, 0.0));
					inter.rotation.x = Math.PI / 2;
					inter.position.x = width / 2;
					inter.position.y = -length /2;
					inter.position.z = height / 2;
					wallMesh.add(inter);
					
					var outSide = new THREE.Mesh(new THREE.PlaneGeometry(length, height), new THREE.MeshBasicMaterial({color: wallColor}));
					outSide.lookAt(new THREE.Vector3(-1.0, 0.0, 0.0));
					outSide.rotation.x = Math.PI / 2;
					outSide.position.x = -width / 2;
					outSide.position.y =- length / 2;
					outSide.position.z = height / 2;
					wallMesh.add(outSide);
					
					var back = new THREE.Mesh(new THREE.PlaneGeometry(width, height), new THREE.MeshBasicMaterial({color: wallColor}));
					back.lookAt(new THREE.Vector3(0.0, 1.0, 0.0));
					back.rotation.z = 0;
					back.position.y = 0;
					back.position.z = height / 2;
					back.doubleSide = true;
					wallMesh.add(back);
					
					var front = new THREE.Mesh(new THREE.PlaneGeometry(width, height), new THREE.MeshBasicMaterial({color: wallColor}));
					front.lookAt(new THREE.Vector3(0.0, -1.0, 0.0));
					front.rotation.z = 0;
					front.position.x = 0;
					front.position.y = -length;
					front.position.z = height / 2;
					wallMesh.add(front);
					
					var top = new THREE.Mesh(new THREE.PlaneGeometry(width, length), new THREE.MeshBasicMaterial({color: 0xffffff}));
					top.lookAt(new THREE.Vector3(0.0, 0.0, 1.0));
					top.position.x = 0;
					top.position.y = -length/2;
					top.position.z = height;
					wallMesh.add(top);
					
					
					if (div.x != 0 || div.y != 0) {
						wallMesh.rotation.z = new THREE.Vector3(div.x, div.y, 0).angleTo(new THREE.Vector3(0.0, -1.0, 0.0)) * Math.sign(div.x);
					}
					wallMesh.position.copy(start);
					return wallMesh;
				};
				
				this.setPosition = function(pos) {
					this.mesh.position.copy(pos);
				};
			};
			
			SelectionPointer.prototype = new DisplayedObject();
			function SelectionPointer() {
				this.createMesh = function() {
					var geometry = new THREE.SphereGeometry( 1, 32, 32 ); 
					var material = new THREE.MeshBasicMaterial( {color: 0xffff00} ); 
					this.mesh = new THREE.Mesh( geometry, material );
				};
			};
			
			function SimpleInteraction(engine,floor) {
				this.engine = engine;
				this.floor = floor;
				this.wall = null;
				this.startPoint = null;
				this.selectionObject = null;
				this.start = function() {
					this.selectionObject = new SelectionPointer();
					this.selectionObject.createMesh();
				};
				this.onMouseMove = function(event, intersections) {
					var intersection = null;
					for(i=0; i<intersections.length; ++i) {
						if (intersections[i].object.id == this.floor.mesh.id) {
							intersection = intersections[i];
							break;
						}
					}
						
					if (this.wall != undefined && this.wall != null) {
						if (intersection != null) {
							this.wall.recreateMesh(this.startPoint, new THREE.Vector2(intersection.point.x, intersection.point.y));
							var mesh = this.wall.getMesh();
							mesh.position.z = 0;
							if (this.selectionObject != null) {
								this.selectionObject.getMesh().position.copy(intersection.point);
							}
						}
					}
					
					if (intersection != null) {
						if (this.selectionObject != null) {
							this.selectionObject.getMesh().position.copy(intersection.point);
							this.selectionObject.visible = true;
						} else {
							this.selectionObject.visible = false;
						}
					}
				};
				
				this.onKeyPressed = function(event) {

				};

				this.onClick = function(event, intersections) {
					if (this.wall == undefined || this.wall == null) {
						if (intersections.length > 0) {
							this.wall = new SimpleWall();
							var point = intersections[0].point;
							var pos = new THREE.Vector2(point.x, point.y);
							this.wall.createMesh(pos);
							this.startPoint = pos;
						}
					} else {
						this.engine.objects.push(this.wall);
						this.wall = null;
						this.startPoint = null;
					}
				};
				
				this.getObjects2Display = function() {
					var objects = [];
					if (this.wall != undefined && this.wall != null) {
						objects.push(this.wall);
					}
					if (this.selectionObject != null) {
						objects.push(this.selectionObject);
					};
					return objects;
				};
			};
			
			
			window.engine.init();
			window.engine.start();

		</script>

	</body>
</html>
